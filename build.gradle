import java.util.regex.Pattern

plugins {
    id 'base'
    id 'org.asciidoctor.jvm.convert' version '4.0.3'  // Plugin for HTML generation
    id 'org.asciidoctor.jvm.pdf' version '4.0.3'      // Plugin for PDF generation
    id 'java-library'  // needed for PlantUML dependency resolution

}

wrapper {
    gradleVersion = '8.11'
    distributionType = 'bin'
    distributionUrl = 'https://services.gradle.org/distributions/gradle-8.11-bin.zip'
}


// Project constants and shared configuration
ext {

    // this might change in the future
    schemaFile = file('exam.rng')

    // configuration for arc42 documentation
    docSrcDir = 'arc42-doc'
    docOutputPath = 'build/arc42-doc'
    mainDocFile = '00-arc42-main.adoc'
    tempDir = "${buildDir}/tmp/asciidoc"

    // Explicitly define files affected by ADR automation
    adrConfig = [
        sourceDir: file("${docSrcDir}/decisions"),
        readmeFile: file("${docSrcDir}/decisions/README.md"),
        arc42File: file("${docSrcDir}/09-decisions.adoc")
    ]
}


repositories {
    mavenCentral()
}

configurations {
    jing
    asciidoctorExtensions
}

dependencies {
    jing 'org.relaxng:jing:20220510'
    asciidoctorExtensions 'org.asciidoctor:asciidoctorj:3.0.0'
    asciidoctorExtensions 'org.asciidoctor:asciidoctorj-pdf:2.3.19'  
    asciidoctorExtensions 'org.asciidoctor:asciidoctorj-diagram:2.3.1'
    asciidoctorExtensions 'net.sourceforge.plantuml:plantuml:1.2024.7'
}

// Tasks and code for schema validation
abstract class ValidationTask extends DefaultTask {
    @Inject
    abstract ExecOperations getExecOperations()
    
    def runJingValidation(File xmlFile) {
        def stdout = new ByteArrayOutputStream()
        def stderr = new ByteArrayOutputStream()
        
        def execResult = execOperations.exec { spec ->
            spec.workingDir = project.projectDir
            spec.executable = 'java'
            spec.args = [
                '-cp',
                project.configurations.jing.asPath,
                'com.thaiopensource.relaxng.util.Driver',
                project.schemaFile.absolutePath,
                xmlFile.absolutePath
            ]
            spec.standardOutput = stdout
            spec.errorOutput = stderr
            spec.ignoreExitValue = true
        }
        
        def error = stderr.toString().trim()
        def output = stdout.toString().trim()
        def allOutput = error.isEmpty() ? output : error
        
        return [
            success: execResult.exitValue == 0,
            output: allOutput
        ]
    }
}

tasks.register('validateFile', ValidationTask) {
    description = 'Validates a single XML file against the RelaxNG schema'
    group = 'Validation'
    
    doLast {
        if (!project.hasProperty('file')) {
            throw new GradleException("Please provide a file path using -Pfile=path/to/file.xml")
        }
        
        def xmlFile = project.file(project.property('file'))
        if (!xmlFile.exists()) {
            throw new GradleException("File ${xmlFile.absolutePath} does not exist")
        }
        
        println "Validating ${xmlFile.name} against schema ${project.schemaFile.name}"
        def result = runJingValidation(xmlFile)
        
        if (result.success) {
            println "✓ ${xmlFile.name} is valid"
        } else {
            println "✗ ${xmlFile.name} validation failed:"
            if (result.output) {
                println result.output
            }
            throw new GradleException("XML validation failed")
        }
    }
}

tasks.register('validate', ValidationTask) {
    description = 'Validates all XML files in predefined directories against the RelaxNG schema'
    group = 'Validation'
    
    doLast {
        def directories = ['mock']  // Add more directories as needed
        def failures = []
        def validCount = 0
        def totalCount = 0
        
        directories.each { dirName ->
            def directory = project.file(dirName)
            if (!directory.exists() || !directory.isDirectory()) {
                println "Warning: Directory ${directory.absolutePath} does not exist"
                return
            }
            
            def xmlFiles = project.fileTree(directory).include('**/*.xml')
            
            xmlFiles.each { xmlFile ->
                totalCount++
                def result = runJingValidation(xmlFile)
                
                if (result.success) {
                    validCount++
                    print "."
                } else {
                    failures << [file: xmlFile.name, output: result.output]
                    print "F"
                }
            }
        }
        
        println "\n\nValidation Summary:"
        println "✓ ${validCount}/${totalCount} files are valid"
        
        if (failures) {
            println "\nFailed validations:"
            failures.each { failure ->
                println "\n✗ ${failure.file} failed validation:"
                println failure.output
                println "-" * 80  // Separator line
            }
            throw new GradleException("${failures.size()} file(s) failed validation")
        }
    }
}

// Task provided by org.asciidoctor.jvm.convert plugin
// Converts AsciiDoc to HTML output
tasks.named('asciidoctor') {
    group = 'documentation'
    description = 'Converts AsciiDoc documentation to HTL format (output in dist/html)'
    configurations 'asciidoctorExtensions'
    baseDirFollowsSourceFile()
    sourceDir docSrcDir
    sources {
        include mainDocFile
    }
    
    outputDir file("${docOutputPath}/html")
    
    attributes = [
        'source-highlighter': 'rouge',
        'toc': 'left',
        'toclevels': '2',
        'sectlinks': '',
        'sectanchors': '',
        'numbered': '',
        'imagesdir': 'images',
        'plantuml-format': 'svg',
        'diagram-svg-type': 'inline'
    ]

    asciidoctorj {
        requires('asciidoctor-diagram')
        modules {
            diagram.use()
        }
    }
}

// Task provided by org.asciidoctor.jvm.pdf plugin
// Converts AsciiDoc to PDF output
tasks.named('asciidoctorPdf') {
    group = 'documentation'
    description = 'Converts AsciiDoc documentation to PDF format (output in dist/pdf)'
    configurations 'asciidoctorExtensions'  
    baseDirFollowsSourceFile()
    sourceDir docSrcDir
    sources {
        include mainDocFile
    }
    
    outputDir file("${docOutputPath}/pdf")
    
    attributes = [
        'pdf-stylesdir': 'themes',
        'pdf-style': 'basic',
        'toc': '',
        'toclevels': '2',
        'numbered': '',
        'imagesdir': 'images',
        'plantuml-format': 'svg',
        'diagram-svg-type': 'inline'
    ]

    asciidoctorj {
        requires('asciidoctor-diagram')
        modules {
            diagram.use()
        }
    }

}

// Clean tasks
tasks.register('cleanDoc', Delete) {
    group = 'documentation'
    description = 'Cleans the distribution directory for the documentation (dist)'
    delete docOutputPath
}


// Main documentation build task
tasks.register('buildDocs') {
    group = 'documentation'
    description = 'Generates complete documentation in all formats (HTML and PDF) after cleaning the output directory'
    dependsOn 'cleanDoc', 'asciidoctor', 'asciidoctorPdf'
}

// Ensure proper task ordering - clean must complete before generation starts
tasks.named('asciidoctor') {
    mustRunAfter 'cleanDoc'
    inputs.dir(docSrcDir)
    outputs.dir(file("${docOutputPath}/html"))
}

tasks.named('asciidoctorPdf') {
    mustRunAfter 'cleanDoc'
    inputs.dir(docSrcDir)
    outputs.dir(file("${docOutputPath}/pdf"))

}

// ADR management task to update the ADR index in README.md

tasks.register('updateAdrIndex') {
    group = 'documentation'
    description = 'Updates ADR indices in README.md and architecture documentation'
    
    inputs.dir(adrConfig.sourceDir)
    outputs.files(adrConfig.readmeFile, adrConfig.arc42File)
    
    def ADR_START_MARKER_MD = '<!-- BEGIN-ADR-INDEX - autogenerated, manual edits will be lost -->'
    def ADR_END_MARKER_MD = '<!-- END-ADR-INDEX -->'
    def ADR_START_MARKER_ADOC = '// BEGIN-ADR-INDEX - autogenerated, manual edits will be lost'
    def ADR_END_MARKER_ADOC = '// END-ADR-INDEX'
    // Execute during configuration phase since asciidoctor needs the results
    def adrs = []
    adrConfig.sourceDir.eachFile { file ->
        if (file.name =~ /^\d{3}-.+\.adoc$/) {
            def content = file.text
            def titleMatch = content =~ /= ADR\d{3} - (.+)/
            def statusMatch = content =~ /== Status\n\n(\w+)/
            
            if (titleMatch) {
                adrs << [
                    id: file.name[0..2],
                    file: file.name,
                    title: titleMatch[0][1],
                    status: statusMatch ? statusMatch[0][1] : 'Unknown'
                ]
            }
        }
    }
    adrs.sort { it.id }
    
    // If no ADRs exist, use placeholder entry
    if (adrs.isEmpty()) {
        adrs << [
            id: '042',
            file: '042-no-adrs-yet.adoc',
            title: 'No ADRs yet, you might want to add some',
            status: 'Proposed'
        ]
    }
    
    // Update README.md
    def readmeContent = generateMarkdownTable(adrs)
    updateFileSection(adrConfig.readmeFile, ADR_START_MARKER_MD, ADR_END_MARKER_MD, readmeContent)
    
    // Update architecture documentation
    def arc42Content = generateAsciiDocTable(adrs)
    updateFileSection(adrConfig.arc42File, ADR_START_MARKER_ADOC, ADR_END_MARKER_ADOC, arc42Content)
}

def generateMarkdownTable(adrs) {
    def content = '| ADR | Status | Title |\n|--|--|-------|\n'
    adrs.each { adr ->
        content += "| [${adr.id}](${adr.file}) | ${adr.status} | ${adr.title} |\n"
    }
    content
}

def generateAsciiDocTable(adrs) {
    def content = '.Architectural Decision Records\n[options="header",cols="1,2,4"]\n|===\n|ADR |Status |Title\n\n'
    adrs.each { adr ->
        content += "|<<${adr.file},${adr.id}>> |${adr.status} |${adr.title}\n"
    }
    content += '|===\n'
    content
}

def updateFileSection(file, sectionStart, sectionEnd, newContent) {
    def text = file.text
    def pattern = Pattern.compile("${Pattern.quote(sectionStart)}.*${Pattern.quote(sectionEnd)}", Pattern.DOTALL)
    file.text = text.replaceAll(pattern, "${sectionStart}\n${newContent}${sectionEnd}")
    println "Updated ${file.name}"
}

// Make documentation tasks depend on ADR index update
tasks.matching { it.name in ['asciidoctor', 'asciidoctorPdf'] }.all {
    dependsOn 'updateAdrIndex'
}


